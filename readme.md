This repo stores benchmarks for the project using LLM.

As for the simple test folder, it only tests a function 'sizeof' in C language. To show the result, you can directly run the 'main' void in 'simple test/src/sizeofTest.java'. The expected result is, ignoring warning messages, it prints 'Size of MyObject instance: 32 bytes' twice. Actually, it calculates the size of a struct defined in both sizeOfTest.java and sizeof.c, in two different ways, one is using Unsafe as another is using FFM api.

Note that there exists two problems for the simple test. One is, when using FFM api to calculate the size, I simply defined the same struct in sizeof.c, which is not a good solution. That means, as long as I change the struct in the java file, I should also change sizeof.c. Another problem is, in the struct, if we define ```char[] str``` in both files, the result looks good. However, if we use String instead, the result of java file and C file differs. A potential reason is the memory management method of the two languages have a little difference, as the exact reason is not clear yet.

As for the test from 'My Well Grounded Java', it contains two versions of a simple project about a bank account. The ```Account.java``` is an interface, and there are three kinds of accounts. Note that there are tests for each type of accounts. The unsafe version allocate memory for the variable ```balance```, while the FFM version allocate off-heap memory to do the same thing. Tests for atomic and synchronized accounts all work well, as tests for var handled accounts sometimes fail, for both FFM version and unsafe version. Hence the failure occurs due to the unsafe version itself but not the way I modify it.

As for the test for data structures, the original version is at https://github.com/HagarMeir/transactionLib. In ```Index.java```, it uses Unsafe to 1) allocate memory for a variable ```headOffset```, which indicates the offset of the field named head; 2) compare and swap objects atomically using ```UNSAFE.compareAndSwapObject```. The first usage is easy to transform, because FFM api can also allocate memory for a int variable. However, the ```headOffset``` is used to get the value at the position ```&object+headOffset```, which is hard to do in Java. It's a thick that in this project, where ```&object+headOffset``` is actually ```object.head```, which can be extracted using ```AtomicReferenceFieldUpdater```. To be honest, I first tried to ignore such transparent exposure, and pass the object type parameters to a library generated by a C program with FFM api. But I failed to do so, as I couldn't find a way to define a memory segment to allocate memory for this object, knowing neither the memory layout or the address of the object. Then I tried to pass the attributes in the object to the ```compareAndSwapObject``` (short for ```cas``` below) function, but there are too many attributes and I was confused should I really have to do it. Althrough I didn't choose to do it, I have to say it is the closest way to do automatically transform in my thought. I also tried to overload ```object.toStirng()``` so that I can pass a string instead of an object. I worked a lot to overload them and write construct functions using a string, and there were many clues in my commit indicated how I tried. However, when I rewrote the ```cas``` function, I realised that there was a easier way, which was the newest commit. I could use ```AtomicReferenceFieldUpdater``` to compare and swap easier. Fortunately, all tests are passed. What's more, it's important that my method to transform this project is not extensible to other projects, at least not for automatic transformation. Because what I do is based on my comprehension of the project, doing some compulsory polishment, and my transformation doesn't use FFM api at all. To run this project, please make sure that the target bytecode version in Settings/Java Complier and the Java version in Run Configurations are both 22.

--------------------------------

Unfortunately, I find it hard or even impossible to transform a project using UNSAFE to an FFM version, mainly because the functionality set of UNSAFE is larger than FFM. If we use UNSAFE to allocate memory for an object with some functions, itâ€™s hard to use FFM to do the same thing because we must know the address of the object as long as we want to pass the object to another library generated by C language or some other languages. However, there is only one way to get the address of an object, and that is UNSAFE. So, such a transformation is impossible, theoretically.

Below is a table that describe what I mean in detail. Briefly, only objects that can be allocated using `MemorySegment` are able to do such a transformation. You can refer to https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/SegmentAllocator.html for detailed information.

Here I do not consider pointers, because they are typically not supported in Java.

| What Type of Variable FFM Can Replace |                             How                              |
| :-----------------------------------: | :----------------------------------------------------------: |
|                  int                  | You can use `arena.allocate(ValueLayout.JAVA_INT, number)` to transform, and a sample project is in 'My Well Grounded Java' folder. Note that `JAVA_INT_UNALIGNED` is omitted because it is similar to int. |
|                 byte                  |       `arena.allocate(ValueLayout.JAVA_BYTE, number)`        |
|                 char                  |       `arena.allocate(ValueLayout.JAVA_CHAR, number)`        |
|                double                 |      `arena.allocate(ValueLayout.JAVA_DOUBLE, number)`       |
|                 float                 |       `arena.allocate(ValueLayout.JAVA_FLOAT, number)`       |
|                 long                  |       `arena.allocate(ValueLayout.JAVA_LONG, number)`        |
|                 short                 |       `arena.allocate(ValueLayout.JAVA_SHORT, number)`       |
|               int array               | `arena.allocate(ValueLayout.JAVA_INT, number1, number2, ..., numbern)` |
|      another basic type of array      | They are similar to the int array, and the basic types are listed above. |
|     struct without function in it     | You can use `arena.allocate(MemoryLayout.structLayout(ValueLayout.xxx))` to allocate memory for a C-type struct, and a sample project is in the 'simple test' folder. |

|          What Type of Variable FFM Can Not Replace           |                             Why                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                 struct with functions in it                  | It's not able to allocate memory for a function, as shown in the 'test for Transactional Data Structure Libraries' folder. |
| use Unsafe to get the value at specified address of a struct | For example, there is a struct `ptr` contains an int variable and a string. If you use this struct by visit specified address using `UNSAFE.compareAndSwapObject(xxx, 3, xxx, xxx)`which means you need the 5th value in the memory of the struct, you can not use FFM to replace it. |
