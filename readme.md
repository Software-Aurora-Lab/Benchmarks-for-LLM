This repo stores benchmarks for the project using LLM.

As for the simple test folder, it only tests a function 'sizeof' in C language. To show the result, you can directly run the 'main' void in 'simple test/src/sizeofTest.java'. The expected result is, ignoring warning messages, it prints 'Size of MyObject instance: 32 bytes' twice. Actually, it calculates the size of a struct defined in both sizeOfTest.java and sizeof.c, in two different ways, one is using Unsafe as another is using FFM api.

Note that there exists two problems for the simple test. One is, when using FFM api to calculate the size, I simply defined the same struct in sizeof.c, which is not a good solution. That means, as long as I change the struct in the java file, I should also change sizeof.c. Another problem is, in the struct, if we define ```char[] str``` in both files, the result looks good. However, if we use String instead, the result of java file and C file differs. A potential reason is the memory management method of the two languages have a little difference, as the exact reason is not clear yet.

As for the test from 'My Well Grounded Java', it contains two versions of a simple project about a bank account. The ```Account.java``` is an interface, and there are three kinds of accounts. Note that there are tests for each type of accounts. The unsafe version allocate memory for the variable ```balance```, while the FFM version allocate off-heap memory to do the same thing. Tests for atomic and synchronized accounts all work well, as tests for var handled accounts sometimes fail, for both FFM version and unsafe version. Hence the failure occurs due to the unsafe version itself but not the way I modify it.

As for the test for data structures, the original version is at https://github.com/HagarMeir/transactionLib. In ```Index.java```, it uses Unsafe to 1) allocate memory for a variable ```headOffset```, which indicates the offset of the field named head; 2) compare and swap objects atomically using ```UNSAFE.compareAndSwapObject```. The first usage is easy to transform, because FFM api can also allocate memory for a int variable. However, the ```headOffset``` is used to get the value at the position ```&object+headOffset```, which is hard to do in Java. It's a thick that in this project, where ```&object+headOffset``` is actually ```object.head```, which can be extracted using ```AtomicReferenceFieldUpdater```. To be honest, I first tried to ignore such transparent exposure, and pass the object type parameters to a library generated by a C program with FFM api. But I failed to do so, as I couldn't find a way to define a memory segment to allocate memory for this object, knowing neither the memory layout or the address of the object. Then I tried to pass the attributes in the object to the ```compareAndSwapObject``` (short for ```cas``` below) function, but there are too many attributes and I was confused should I really have to do it. Althrough I didn't choose to do it, I have to say it is the closest way to do automatically transform in my thought. I also tried to overload ```object.toStirng()``` so that I can pass a string instead of an object. I worked a lot to overload them and write construct functions using a string, and there were many clues in my commit indicated how I tried. However, when I rewrote the ```cas``` function, I realised that there was a easier way, which was the newest commit. I could use ```AtomicReferenceFieldUpdater``` to compare and swap easier. Fortunately, all tests are passed. What's more, it's important that my method to transform this project is not extensible to other projects, at least not for automatic transformation. Because what I do is based on my comprehension of the project, doing some compulsory polishment, and my transformation doesn't use FFM api at all. To run this project, please make sure that the target bytecode version in Settings/Java Complier and the Java version in Run Configurations are both 22.